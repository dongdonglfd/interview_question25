#### 1.为什么算不对

为什么运算结果与我们想的不一样呢，尝试解释一下原理。

```c
int main() {
    unsigned char a = 129;
    char b = 129;
    printf("a = %d, b = %d\n", a, b);

    a += 100;
    b += 100;
    printf("a = %d, b = %d\n", a, b);

    float c = 1.2345678;
    printf("c = %.20f, c = %.3f, (int)c = %d, (double)(int)c = %.20f\n", c, c, (int)c, (double)(int)c);
    printf("c - 0.0000001 = %f", c - 0.0000001);
}
```

------

| **出题人** | **苏国诚**   |
| ---------- | ------------ |
| 知识点1    | 强制类型转换 |
| 知识点2    | 格式化输出   |
| 知识点3    | 数值上溢     |
| 知识点4    | 浮点数精度   |

------

Q1.解释a和b为什么一个算对了一个算不对，讲讲数值上溢 40%

Q2.讲讲强制类型转换 35%

Q3.解释为什么浮点数计算会不精确 25%

```
A1：
每个数据类型都会有它的取值范围，超过了这个取值范围，就会与我们的预期结果不一致。unsigned char类型因为占1字节，所以有8位二进制可以表示，有2的8次方种变化，也就是可以表示2的8次方个数字，即0-255。char类型也是一样，但它表示的是-128-127。超过这个范围，就会从最小值开始重新递加。
A2：
强制类型转换因为不同数据类型的存储方式不同，会导致损失精度甚至改变数据。
A3：
浮点数由于小数部分转换为二进制时可能会除不尽，但是计算机还要存储它，所以只能截下有限的位数（float类型的尾数有23位，double类型的尾数是52位），这样就会损失一定的精度。
```
